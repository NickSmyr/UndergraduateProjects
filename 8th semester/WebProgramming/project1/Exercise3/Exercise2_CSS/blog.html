<!DOCTYPE html>
<html lang="el">
    <head>
        <link rel="stylesheet" href="./stylesheet.css">
        <meta charset="utf-8">
        <title>Αυτοβιογραφικό σημείωμα - Νικόλαος Σμυρνιούδης</title>
    </head>
    <body>
        <!--Header-->
        <header>
            <img src="images/background.jpeg" alt="background" width="500" height="300">
            <p>Νικόλαος Σμυρνιούδης - IT Specialist</p>
        </header>
        <nav>
            <ul>
                <li><a href="index.html">Αρχικη</a></li>
                <li><a href="blog.html">Blog</a></li>
                <li><a href="contact.html">Επικοινωνία</a></li>
            </ul>
        </nav>
        <main>
            <article>
                <section>
                    <h1>Καταλάθος τετραγωνική πολυπλοκότητα</h1>
                    <h2>Εισαγωγή</h2>
                    <p>
                        Όταν δημιουργούμε data processing scripts π.χ. για την εκπάιδευση ενός νευρωνικού δικτύου στην αρχή τα 
                        φτιάχνουμε και τα δοκιμάζουμε με μικρά αρχεία. Ωστόσο σε γλώσσες υψηλού επιπέδου προσπαθούμε να γράψουμε
                        κώδικα γρήγορα και αυτό μπορεί να οδηγήσει σε προβλήματα μόλις αρχίζουμε να χειριζόμαστε δεδομένα μεγαλύτερης κλίμακας
                    </p>
                    <p>
                        Για παράδειγμα, εγώ έγραφα κώδικα για εναν αλγόριθμο μηχανικής μάθησης με scikit και σε κάθε βήμα ήθελα να υπολογίζω το f1 score
                        που είχε πετύχει το μοντέλο ως εκείνη την στιγμή. Ο κώδικας ήταν πάνω κάτω ο εξής:
                        <code>
                            current_f1 = f1_score(y_true,y_pred)
                        </code>
                        Ωστόσο, η συνάρτηση <code>f1_score</code> δέχεται ως είσοδο όλες τις προβλέψεις του μοντέλου σε κάθε χρονική στιγμή, που σημαίνει πως
                        έχει γραμμική πολυπλοκότητα. Επειδή όμως σε κάθε παράδειγμα εκπαίδευσης αυτή η συνάρτηση εκτελείται μια φορά,
                        καταλήγουμε σε τετραγωνικό χρόνο. 
                    </p>
                </section>
                <section>
                    <h2>Εντοπίζοντας λάθη και βελτιώση επίδοσης προγραμμάτων</h2>
                    Συνήθως για να βρούμε λάθη για προγράμματα χρησιμοποιούμε είτε print statements η κάποιο sophisticated debugger.
                    <blockquote>
                        The most effective debugging tool is still careful thought, coupled with judiciously placed print statements. -Brian Kernighan
                    </blockquote>
                    Ωστόσο στην περίπτωση μου, ο κώδικας δούλευε αλλα δεν ήταν αρκετά αποδοτικός. Ένας διάσημος τρόπος για βελτίωση επίδοσης του κώδικα
                     είναι τα <a href="http://www.brendangregg.com/flamegraphs.html">flame graphs</a> που απαιτούν 
                     <a href="https://en.wikipedia.org/wiki/Profiling_(computer_programming)">Profiling</a>. Ωστόσο κάτι ποιό απλό που εφάρμοσα είναι ο συνδυασμός
                     του <a href="https://github.com/tqdm/tqdm">tqdm</a> και αφαίρεση κώδικα. Στό κύριο loop του προγράμματος υπήρχαν 300000 iterations που έπρεπε να 
                     επεξεργαστούν. Όσο ο αλγόριθμος ήταν τετραγωνικός ο ρυθμός που επεξεργάζεται κάθε παράδειγμα εκπαίδευσης μειώνεται γραμμικά. To tqdm, by default 
                     δείχνει το ρυθμό των iteration οπότε για μένα έιναι εύκολο να καταλάβω πότε ο αλγόριθμος είναι τετραγωνικός και πότε γραμμικός. Όταν διαγράψω
                     τις περισσότερες γραμμές ο αλγόριθμος γίνεται γραμμικός, πράγμα που σημαίνει πως μία απο της γραμμές κώδικα που διέγραψα ήταν υπεύθυνη για την
                     κακή επίδοση του προγράμματος. 
                </section>
            </article>
        </main>
        <footer>
            <p>Copyright 2021 - N.Smyrnioudis</p>
        </footer>
    </body>
</html>